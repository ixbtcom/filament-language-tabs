# Builder Locale Status Fix

## Context
- При редактировании блоков в `Builder` внутри `LanguageTabs` заголовок таба (`Blocks ru` ↔ `Blocks en`) меняется, но индикатор заполненности локали остаётся прежним.
- Поведение воспроизводится и для других контейнеров, использующих массив состояния (Repeater, Grid).
- Два внутренних исследования (`tasks/fix-builder.md`, `tasks/builder-refresh.md`) описывают разные грани проблемы.

## Ключевые выводы
- `LanguageTabs::prepareFieldForLocale()` навешивает собственный `afterStateHydrated`, перетирая тот, что регистрирует `Filament\Forms\Components\Builder` в `setUp()`. Итог — Builder теряет нормализацию state (UUID-ключи, пустой массив по умолчанию) и в Livewire остаётся «старый» снимок.
- При обновлении мы вызываем `$set($attribute, $translations, shouldCallUpdatedHooks: true)` только для корневого атрибута (`content`), поэтому `refreshFormData([$attribute])` не триггерит наблюдателей, подписанных на `content.en`.
- Анализ в `tasks/fix-builder.md` предлагает настраивать хуки на уровне контейнера (Builder/Repeater) и делегировать остальное Filament, но без сохранения базовых хуков Filament остаётся вышеописанная поломка.
- Анализ в `tasks/builder-refresh.md` добавляет требование: прежде чем писать собственную логику, нужно вызвать исходный гидратор и нормализовать массивы, а также дергать `refreshFormData` по конкретной локали.

## Рекомендуемая реализация
1. **Чейнить существующие хуки Filament.** Перед установкой своих коллбеков сохранить внутри компонента исходные `afterStateHydrated`/`afterStateUpdated` (через замыкание или рефлексию) и вызвать их первыми. Это вернёт UUID-ключи и корректную инициализацию Builder.
2. **Контейнерные адаптеры.** Реализовать методы `prepareBuilderForLocale()` и `prepareRepeaterForLocale()` по паттерну из `tasks/fix-builder.md`, но с учётом шага 1. Для вложенных полей достаточно `callAfterStateUpdated()` самого контейнера — Filament пробрасывает события вверх.
3. **Нормализация пустых состояний.** Если `Arr::get($translations, $locale)` вернул `null`, подавать `[]` в `->state()` для контейнеров, чтобы их экшены работали предсказуемо.
4. **Целевые refresh-пути.** После `$set(...)` вызывать `refreshFormData(["{$attribute}.{$locale}", $attribute])`, чтобы обновились и атрибут, и конкретная локаль (иначе бейджи и валидация могут оставаться старыми).
5. **Глубокое клонирование при необходимости.** Если в форму добавлены кастомные блоки/повторители, которые разделяют состояние, использовать `deepCloneComponent()` из плана в `tasks/fix-builder.md`.

## Тестирование
- Добавить Livewire-тест: изменить блок в `content.en`, ожидать что `content['en'][0]['data']` обновился и статус таба меняется.
- Проверить Repeater аналогичным образом.
- Регресс: убедиться, что сохранение существующих данных не ломается (hydrate → update → persist).

Эта стратегия совмещает лучшие части обоих подходов: мы пользуемся контейнерными хуками, но больше не ломаем нативные механизмы Filament и заставляем Livewire реагировать на обновление конкретной локали.
